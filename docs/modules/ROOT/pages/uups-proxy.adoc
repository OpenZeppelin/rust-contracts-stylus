= UUPS Proxy

The Universal Upgradeable Proxy Standard (UUPS) is a minimal and gas-efficient
pattern for upgradeable contracts. Defined in the xref:https://eips.ethereum.org/EIPS/eip-1822[ERC-1822]
specification, UUPS delegates upgrade logic to the implementation contract
itself — reducing proxy complexity and deployment costs.

The OpenZeppelin Stylus Contracts provide a full implementation of the UUPS pattern via `UUPSUpgradeable` and `Erc1967Proxy`.

== Overview

UUPS uses the ERC-1967 proxy architecture to separate upgrade logic from proxy behavior. Instead of maintaining upgradeability in the proxy, all upgrade control is implemented within the logic contract.

Key components:

- **Proxy Contract (`Erc1967Proxy`)** — delegates calls via `delegate_call`.
- **Implementation Contract** — contains application logic and upgrade control.
- **Upgrade Functions** — reside in the implementation, not the proxy.

In Solidity, upgrade safety guarantees rely on `immutable` variables and context checks. Stylus, however, requires small design adaptations which are covered in the sections below.

== Immutable Workaround

Stylus does not currently support the `immutable` keyword. Solidity stores `__self = address(this)` as immutable, whereas Stylus must store the contract address in a dedicated storage slot:

[source,rust]
----
self_address: Address;
----

This field is initialized once in the constructor and never changed afterwards.

To differentiate between calls coming from the proxy vs direct calls to the implementation, Stylus uses a special `MAGIC_PROXY_VALUE` constant, which is set to `keccak256('Stylus.eip1967.proxy') - 1` to avoid storage collisions.

**Purpose:**
- Marks the contract as being called via a proxy delegate call.
- Prevents direct invocation of upgrade functions on the implementation contract.
- Ensures UUPS upgrade safety checks behave like Solidity’s `__self` comparison.

Although this consumes a storage slot (unlike an `immutable`), it provides the same upgrade-safety property:
the contract can distinguish between calls to the implementation contract and calls via a proxy.

== Initialization

Stylus requires explicit initialization for both the implementation and the proxy:

- **Constructor** – called exactly once on deployment of the logic (implementation) contract.
This sets the `self_address` field to the contract’s own deployed address.
- **Initialize function** – called exactly once when deploying through a proxy.
This sets the proxy’s state (e.g. admin, initialization variables) and marks the contract
as operating in a proxy context.

[NOTE]
====
Calling initialize more than once, or failing to call it when deploying through a proxy, can leave the contract vulnerable to takeover or permanently unupgradeable.
====

**Trade-offs:**

- **Storage Cost:** Requires one additional storage slot.
- **Runtime Safety:** Maintains the same guarantees as the Solidity version.
- **Gas Impact:** One-time cost during initialization; negligible runtime overhead.

== Why UUPS?

- **Gas Efficient** — Upgrades are handled within the logic contract.
- **Secure** — Authorization and validation are managed in one place.
- **Standardized** — Conforms to ERC-1822 and ERC-1967.
- **Flexible** — Upgrade logic can include custom access control and validation.
- **Safe by Design** — Uses dedicated ERC-1967 slots to prevent storage collisions.

== How It Works

. Deploy `Erc1967Proxy` with an initial implementation and encoded `initialize` data.
. Proxy delegates all calls to the implementation contract via `delegate_call`.
. Implementation exposes `upgrade_to_and_call`, guarded by access control (e.g. `Ownable`).
. Upgrades validate the new implementation using `proxiable_uuid()`.
. Stylus requires a two-step initialization pattern: `constructor` on deployment, then `initialize` during proxy setup.

== Implementing a UUPS Contract

Minimal example with `Ownable`, `UUPSUpgradeable`, and `Erc20` logic:

[source,rust]
----
#[entrypoint]
#[storage]
struct MyUUPSContract {
    erc20: Erc20,
    ownable: Ownable,
    uups: UUPSUpgradeable,
}

#[public]
#[implements(IErc20<Error = erc20::Error>, IUUPSUpgradeable, IErc1822Proxiable, IOwnable)]
impl MyUUPSContract {
    #[constructor]
    fn constructor(
        &mut self,
        initial_owner: Address,
    ) -> Result<(), ownable::Error> {
        self.uups.constructor();
        self.ownable.constructor(initial_owner)
    }

    /// Initializes the contract during proxy setup.
    ///
    /// NOTE: Make sure to provide a proper initialization in your logic
    /// contract, [`Self::initialize`] should be invoked at most once.
    ///
    /// Stylus requires a proxy-specific setup. The `MAGIC_PROXY_VALUE` is
    /// used to differentiate between direct calls and proxy delegate calls.
    fn initialize(&mut self, owner: Address) -> Result<(), ownable::Error> {
        self.uups.initialize()?;
        self.ownable.constructor(owner)
    }

    fn mint(&mut self, to: Address, value: U256) -> Result<(), erc20::Error> {
        self.erc20._mint(to, value)
    }
}

#[public]
impl IUUPSUpgradeable for MyUUPSContract {
    #[selector(name = "UPGRADE_INTERFACE_VERSION")]
    fn upgrade_interface_version(&self) -> String {
        self.uups.upgrade_interface_version()
    }

    fn upgrade_to_and_call(&mut self, new_impl: Address, data: Bytes) -> Result<(), Vec<u8>> {
        // Make sure to provide upgrade authorization in your implementation
        // contract.
        self.ownable.only_owner()?; // authorization
        self.uups.upgrade_to_and_call(new_impl, data)?; // perform upgrade
        Ok(())
    }
}
----

== Implementing the Proxy

A simple UUPS-compatible proxy using ERC-1967:

[source,rust]
----
#[entrypoint]
#[storage]
struct MyUUPSProxy {
    proxy: Erc1967Proxy,
}

#[public]
impl MyUUPSProxy {
    #[constructor]
    fn constructor(&mut self, implementation: Address, data: Bytes) -> Result<(), erc1967::utils::Error> {
        self.proxy.constructor(implementation, &data)
    }

    fn implementation(&self) -> Result<Address, Vec<u8>> {
        self.proxy.implementation()
    }

    #[fallback]
    fn fallback(&mut self, calldata: &[u8]) -> ArbResult {
        unsafe { self.proxy.do_fallback(calldata) }
    }
}

unsafe impl IProxy for MyUUPSProxy {
    fn implementation(&self) -> Result<Address, Vec<u8>> {
        self.proxy.implementation()
    }
}
----

== Upgrade Safety

=== 1. Access Control

Upgrades must be restricted to trusted accounts, e.g. via `only_owner`:

[source,rust]
----
self.ownable.only_owner()?;
----

=== 2. Proxy Context Enforcement

Ensures upgrade calls come from a delegate call:

[source,rust]
----
self.uups.only_proxy()?; // Reverts if not called via proxy
----

**Explanation:**
`only_proxy()` internally compares `self_address` to `MAGIC_PROXY_VALUE`.
If they match, the call came through the proxy.
If not, the call is direct on the implementation and will revert, protecting upgrade logic.

=== 3. Proxiable UUID Validation

Guarantees compatibility with UUPS:

[source,rust]
----
self.uups.proxiable_uuid()? == IMPLEMENTATION_SLOT;
----

== Initialization

The UUPS proxy supports initialization data that is delegated to the implementation on deployment.
This is typically used to invoke an initialize function, which sets up the contract's
initial state (e.g. ownership, token supply, config values).

[source,rust]
----
let data = IMyContract::initializeCall {
    selfAddress: proxy_addr,
    owner: alice_addr,
}.abi_encode();

MyUUPSProxy::deploy(implementation_addr, data.into());
----

=== ⚠️ Initialization Must Be Explicit

The implementation contract must expose a properly designed initialize function:
* It should be public.
* It must guard against being called multiple times (e.g., via a storage flag or access check).
* It should set critical state (e.g., ownership, initial balances) that would otherwise be set via constructor logic.
* Failing to implement initialization correctly can lead to:
    * Orphaned contracts with no owner.
    * Uninitialized token supply or core state.
    * Permanent denial of future upgrades.

[source,rust]
----
/// Initializes the contract.
///
/// NOTE: Make sure to provide a proper initialization in your logic
/// contract, [`Self::initialize`] should be invoked at most once.
fn initialize(&mut self, self_address: Address, owner: Address) -> Result<(), ownable::Error> {
    // Some initialization stuff.
    self.ownable.constructor(owner)
}
----

NOTE: initialize is typically called only once during deployment, but since it's public,
you must protect it from being re-executed after the proxy is live.

== Initializing the Proxy

Initialization data is passed to the implementation’s `initialize` function:

[source,rust]
----
let data = IMyContract::initializeCall {
    selfAddress: implementation_addr,
    owner: alice_addr,
}.abi_encode();

MyUUPSProxy::deploy(implementation_addr, data.into());
----

This setup call is run via `delegate_call` during proxy deployment.

== Security Best Practices

* Restrict upgrade access (e.g. `only_owner`).
* Validate all upgrade targets.
* Test upgrades across versions.
* Monitor upgrade events (`Upgraded`).
* Use empty data unless initialization is needed.
* Ensure new implementations return the correct `proxiable UUID`.
* **Enforce proxy context checks** — `only_proxy()` ensures upgrades cannot be called directly on the implementation.

== Common Pitfalls

* Forgetting access control.
* Direct calls to upgrade logic (not via proxy).
* Missing `proxiable UUID` validation.
* Changing storage layout without planning.
* Sending ETH to constructor without data (will revert).

== Use Cases

* Upgradeable tokens standards (e.g. ERC-20, ERC-721, ERC-1155).
* Modular DeFi protocols.
* DAO frameworks.
* NFT marketplaces.
* Access control registries.
* Cross-chain bridges.

== Related

* xref:erc1967.adoc[ERC-1967 Proxy]
* xref:beacon-proxy.adoc[Beacon Proxy]
* xref:proxy.adoc[Basic Proxy]
