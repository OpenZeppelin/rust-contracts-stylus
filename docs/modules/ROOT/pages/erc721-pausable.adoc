= ERC-721 Pausable

ERC721 token with pausable token transfers, minting, and burning.

Useful for scenarios such as preventing trades until the end of an evaluation period, or having an emergency switch for freezing all token transfers, e.g. caused by a bug.

[[usage]]
== Usage

In order to make your ERC721 token `pausable`, you need to use the https://docs.rs/openzeppelin-stylus/0.1.1/openzeppelin_stylus/utils/pausable/index.html[`Pausable`] contract and apply its mechanisms to ERC721 token functions as follows:

[source,rust]
----
use openzeppelin_stylus::{
    token::erc721::Erc721,
    utils::Pausable,
};

sol_storage! {
    #[entrypoint]
    struct PausableErc721 {
        #[borrow]
        Erc721 erc721;
        #[borrow]
        Pausable pausable;
    }
}

#[public]
#[inherit(Erc721, Pausable)]
impl PausableErc721 {
    pub fn burn(&mut self, token_id: U256) -> Result<(), Vec<u8>> {
        self._update(Address::ZERO, token_id, msg::sender())?;
        Ok(())
    }

    pub fn mint(&mut self, to: Address, token_id: U256) -> Result<(), Vec<u8>> {
        // ...
        let previous_owner = self._update(to, token_id, Address::ZERO)?;
        // ...
        Ok(())
    }

    pub fn safe_transfer_from(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
    ) -> Result<(), Vec<u8>> {
        self.safe_transfer_from_with_data(from, to, token_id, vec![].into())
    }

    #[selector(name = "safeTransferFrom")]
    pub fn safe_transfer_from_with_data(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
        data: Bytes,
    ) -> Result<(), Vec<u8>> {
        self.transfer_from(from, to, token_id)?;
        // ...
        Ok(())
    }

    pub fn transfer_from(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
    ) -> Result<(), Vec<u8>> {
        // ...
        let previous_owner = self._update(to, token_id, msg::sender())?;
        // ...
        Ok(())
    }
}

impl PausableErc721 {
    fn _update(
        &mut self,
        to: Address,
        token_id: U256,
        auth: Address,
    ) -> Result<Address, Vec<u8>> {
        self.pausable.when_not_paused()?;
        Ok(self.erc721._update(to, token_id, auth)?)
    }
}
----

Additionally, you need to ensure proper initialization during xref:deploy.adoc[contract deployment]. Make sure to include the following code in your Solidity Constructor:

[source,solidity]
----
contract PausableErc721 {
    bool private _paused;

    constructor() {
        _paused = false;
    }
}
----
